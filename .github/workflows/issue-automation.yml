name: Issue Management Automation
on:
  issues:
    types: [opened, labeled]

jobs:
  create-labels:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v6
        with:
          script: |
            // Define all required labels with their color and description
            const requiredLabels = [
              // Category Labels
              { name: 'bug', color: 'd73a4a', description: 'Something isn\\'t working' },
              { name: 'enhancement', color: 'a2eeef', description: 'New feature or request' },
              { name: 'epic', color: '006b75', description: 'Large feature requiring multiple sub-tasks' },
              { name: 'maintenance', color: 'fef2c0', description: 'Maintenance and housekeeping tasks' },
              // Priority Labels
              { name: 'priority-critical', color: 'b60205', description: 'Critical priority issue' },
              { name: 'priority-high', color: 'ff9f1c', description: 'High priority issue' },
              { name: 'priority-medium', color: 'ffee99', description: 'Medium priority issue' },
              { name: 'priority-low', color: 'bfe5bf', description: 'Low priority issue' },
              // Status Labels
              { name: 'needs-triage', color: 'e6e6e6', description: 'Needs to be reviewed by maintainers' },
              { name: 'needs-review', color: '1d76db', description: 'Awaiting review from maintainers' },
              { name: 'first-time-contributor', color: '0052cc', description: 'Issue created by first-time contributor' }
            ];

            // Create or verify each label exists
            for (const label of requiredLabels) {
              try {
                // Check if label exists
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: label.name
                });
                console.log(`Label '${label.name}' already exists.`);
              } catch (error) {
                if (error.status === 404) {
                  // Create label if it doesn't exist
                  await github.rest.issues.createLabel({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ...label
                  });
                  console.log(`Created label '${label.name}'.`);
                } else {
                  throw new Error(`Error checking/creating label '${label.name}': ${error.message}`);
                }
              }
            }

  issue-triage:
    runs-on: ubuntu-latest
    needs: create-labels
    steps:
      - uses: actions/github-script@v6
        with:
          script: |
            const issue = context.payload.issue;
            const issueTitle = issue.title.toLowerCase();
            const issueBody = (issue.body || '').toLowerCase();
            const currentLabels = issue.labels.map(l => l.name);
            const labelsToAdd = [];

            // Add initial needs-triage label if not present
            if (!currentLabels.includes('needs-triage')) {
              labelsToAdd.push('needs-triage');
            }

            // Add category labels based on title keywords
            if (issueTitle.includes('bug')) {
              if (!currentLabels.includes('bug')) {
                labelsToAdd.push('bug');
              }
            } else if (issueTitle.includes('epic')) {
              if (!currentLabels.includes('epic')) {
                labelsToAdd.push('epic');
              }
            } else if (issueTitle.includes('maintenance')) {
              if (!currentLabels.includes('maintenance')) {
                labelsToAdd.push('maintenance');
              }
            }

            // Add priority labels (highest priority wins)
            const priorityKeywords = {
              'priority-critical': ['critical', 'urgent', 'production', 'outage'],
              'priority-high': ['important', 'high', 'blocking'],
              'priority-medium': ['medium', 'normal'],
              'priority-low': ['low', 'nice-to-have', 'minor']
            };

            let priorityLabel = 'priority-medium'; // Default
            // Check for highest priority first
            for (const [label, keywords] of Object.entries(priorityKeywords)) {
              if (keywords.some(k => issueTitle.includes(k) || issueBody.includes(k))) {
                priorityLabel = label;
                break;
              }
            }

            if (!currentLabels.includes(priorityLabel) && !labelsToAdd.includes(priorityLabel)) {
              labelsToAdd.push(priorityLabel);
            }

            // Add all collected labels to the issue
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labelsToAdd
              });
              console.log(`Added labels: ${labelsToAdd.join(', ')}`);
            } else {
              console.log('No new labels to add for triage.');
            }

  task-breakdown:
    runs-on: ubuntu-latest
    needs: issue-triage
    if: contains(github.event.issue.labels.*.name, 'epic')
    steps:
      - uses: actions/github-script@v6
        with:
          script: |
            const issue = context.payload.issue;
            const parentIssueNumber = issue.number;
            const parentTitle = issue.title;
            const subtasks = [
              { taskNum: 1, name: 'Requirements Analysis' },
              { taskNum: 2, name: 'Design and Architecture' },
              { taskNum: 3, name: 'Implementation' },
              { taskNum: 4, name: 'Testing and Documentation' }
            ];

            const subtaskIssues = [];

            // Create each subtask issue
            for (const subtask of subtasks) {
              const subtaskTitle = `[SUBTASK] ${parentTitle} - Task ${subtask.taskNum}: ${subtask.name}`;
              const subtaskBody = `Related to #${parentIssueNumber}\\n\\nPlease follow the feature request process for this subtask.`;

              const createdIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: subtaskTitle,
                body: subtaskBody,
                labels: ['enhancement', 'needs-review']
              });

              subtaskIssues.push({
                number: createdIssue.data.number,
                title: createdIssue.data.title
              });
              console.log(`Created subtask issue #${createdIssue.data.number}: ${subtaskTitle}`);
            }

            // Update parent issue body with Epic Tasks checklist
            let parentBody = issue.body || '';
            const checklist = subtaskIssues.map(s => `- [ ] #${s.number} - ${s.name}`).join('\\n');
            const epicSection = `\\n\\n## Epic Tasks\\n${checklist}`;

            // Only add the section if it doesn't already exist
            if (!parentBody.includes('## Epic Tasks')) {
              parentBody += epicSection;
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parentIssueNumber,
                body: parentBody
              });
              console.log('Updated parent issue with Epic Tasks checklist.');
            } else {
              console.log('Epic Tasks section already exists in parent issue.');
            }

  auto-response:
    runs-on: ubuntu-latest
    needs: issue-triage
    steps:
      - uses: actions/github-script@v6
        with:
          script: |
            const issue = context.payload.issue;
            const issueNumber = issue.number;
            const author = issue.user.login;
            const currentLabels = issue.labels.map(l => l.name);
            const repo = context.repo.repo;
            const owner = context.repo.owner;

            // 1. Check if this is the author's first issue in this repo
            const authorIssues = await github.rest.issues.listForRepo({
              owner: owner,
              repo: repo,
              creator: author,
              state: 'all',
              per_page: 100 // Get all issues by the author
            });

            const isFirstIssue = authorIssues.data.length <= 1; // Only current issue exists
            if (isFirstIssue && !currentLabels.includes('first-time-contributor')) {
              await github.rest.issues.addLabels({
                owner: owner,
                repo: repo,
                issue_number: issueNumber,
                labels: ['first-time-contributor']
              });
              console.log('Added first-time-contributor label.');
            }

            // 2. Create milestone v1.0.0 if it doesn't exist
            let v1Milestone = null;
            try {
              const milestones = await github.rest.issues.listMilestones({
                owner: owner,
                repo: repo,
                state: 'all'
              });
              v1Milestone = milestones.data.find(m => m.title === 'v1.0.0');
              if (!v1Milestone) {
                v1Milestone = (await github.rest.issues.createMilestone({
                  owner: owner,
                  repo: repo,
                  title: 'v1.0.0',
                  description: 'First major release'
                })).data;
                console.log('Created milestone v1.0.0.');
              }
            } catch (error) {
              console.log(`Error managing milestone: ${error.message}`);
            }

            // 3. Set milestone for priority-high or priority-critical issues
            const hasHighPriority = currentLabels.includes('priority-high') || currentLabels.includes('priority-critical');
            if (hasHighPriority && issue.milestone === null && v1Milestone) {
              await github.rest.issues.update({
                owner: owner,
                repo: repo,
                issue_number: issueNumber,
                milestone: v1Milestone.number
              });
              console.log('Set milestone v1.0.0 for high/critical priority issue.');
            }

            // 4. Post appropriate response comment
            let commentBody = '';
            if (currentLabels.includes('bug')) {
              commentBody = `Thank you for reporting this bug, @${author}! Please follow our [Bug Report Guidelines](https://github.com/${owner}/${repo}/blob/main/.github/ISSUE_TEMPLATE/bug_report.md) to help us resolve this quickly.`;
            } else if (currentLabels.includes('epic')) {
              commentBody = `Thank you for submitting this epic, @${author}! Please follow our [Feature Request Process](https://github.com/${owner}/${repo}/blob/main/.github/ISSUE_TEMPLATE/feature_request.md) to help us deliver this feature successfully.`;
            } else if (currentLabels.includes('maintenance')) {
              commentBody = `Thank you for submitting this maintenance task, @${author}! Please follow our [Maintenance Guidelines](https://github.com/${owner}/${repo}/blob/main/.github/ISSUE_TEMPLATE/maintenance_report.md) to help us complete this task efficiently.`;
            } else {
              commentBody = `Thank you for your issue, @${author}! We'll review it shortly.`;
            }

            // Add welcome message if first issue
            if (isFirstIssue) {
              commentBody += `\\n\\nWelcome to your first issue in this repository! We appreciate your contribution.`;
            }

            // Post comment if not already posted (check existing comments)
            const existingComments = await github.rest.issues.listComments({
              owner: owner,
              repo: repo,
              issue_number: issueNumber
            });

            const hasAutoResponse = existingComments.data.some(c => c.body.includes('Bug Report Guidelines') || c.body.includes('Feature Request Process') || c.body.includes('Maintenance Guidelines'));
            if (commentBody && !hasAutoResponse) {
              await github.rest.issues.createComment({
                owner: owner,
                repo: repo,
                issue_number: issueNumber,
                body: commentBody
              });
              console.log('Posted auto-response comment.');
            } else {
              console.log('Auto-response comment already exists or no comment to post.');
            }

            // 5. Update status labels: remove needs-triage, add needs-review
            if (currentLabels.includes('needs-triage') && !currentLabels.includes('needs-review')) {
              await github.rest.issues.removeLabel({
                owner: owner,
                repo: repo,
                issue_number: issueNumber,
                name: 'needs-triage'
              });
              await github.rest.issues.addLabels({
                owner: owner,
                repo: repo,
                issue_number: issueNumber,
                labels: ['needs-review']
              });
              console.log('Updated status from needs-triage to needs-review.');
            }